raid_home_level = "l10_radar"

local gt = game.translate_string
local art_ini = ini_file("items\\settings\\artefacts.ltx")

local HI = has_alife_info
local GI = give_info
local DI = disable_info

local ctime_to_t = utils_data.CTime_to_table
local t_to_ctime = utils_data.CTime_from_table

local show_hint = true		-- mcm here

local to_translate = {
	["pkm_100"] = true, 	["magnum_300"] = true, 		["357_hp"] = true,
	["af_class_gravi"] = true, 		["af_class_thermo"] = true, 		["af_class_chem"] = true, 	["af_class_electro"] = true,
}

local smarts_blacklist = {
	["pri_a25_smart_terrain"] = true,
	["trc_sim_1"] = true,
	["gar_smart_terrain_5_2"] = true,
	["esc_smart_terrain_9_10"] = true,
	["esc_smart_terrain_2_14"] = true,
	["agr_u_soldiers"] = true,
	["mar_smart_terrain_11_11"] = true,
	["mil_smart_terrain_2_2"] = true,
	["lx8_smart_terrain"] = true,
	["pri_a25_smart_terrain"] = true,
	["pri_b306"] = true,
	["kbo_terrain"] = true,
	["pri_a16_mir_copy"] = true,
}

smarts_blacklist_for_items = {
	["gar_smart_terrain_3_5"] = true,
	["gar_smart_terrain_6_6"] = true,
	["gar_smart_terrain_6_1"] = true,
	["mar_smart_terrain_6_8"] = true,
	["mar_smart_terrain_10_7"] = true,
	["mar_smart_terrain_6_7"] = true,
	["mar_smart_terrain_6_4"] = true,
	["val_smart_terrain_1_2"] = true,
	["val_smart_terrain_6_5"] = true,
	["trc_sim_18"] = true,
	["trc_sim_4"] = true,
	["trc_sim_19"] = true,
	["trc_sim_9"] = true,
	["trc_sim_20"] = true,
	["trc_sim_14"] = true,
	["trc_sim_11"] = true,
	["prom_13"] = true,
	["zat_sim_9"] = true,
	["zat_sim_25"] = true,
	["zat_b42_smart_terrain"] = true,
}

function smart_is_busy(smart_id)
	if raid_tasks_main.raid_busy_smarts_t[smart_id] or raid_events.raid_event_busy_smarts_t[smart_id] then
		return true
	end
end

function find_random_stash(level_name, busy_check)
	local stashes_ar = {}
	for i = 1, 65534 do
		local se_obj = alife_object(i)
		if se_obj and IsInvbox(se_obj) then
			local stash_wo_alive_parent = se_obj.parent_id and ( se_obj.parent_id == 65535 or (alife_object(se_obj.parent_id) and (not alife_object(se_obj.parent_id).alive)) )
			local busy_stash = busy_check and raid_tasks_main.raid_busy_stashes_t[se_obj.id] or false
			local stash_lid = game_graph():vertex(se_obj.m_game_vertex_id):level_id()
			local stash_lname = stash_lid and alife():level_name(stash_lid)
			if (not treasure_manager.caches_blacklist[se_obj:name()]) and stash_wo_alive_parent and (not busy_stash) and stash_lname and (stash_lname == level_name) then
				stashes_ar[#stashes_ar + 1] = se_obj.id
			end
		end
	end

	if #stashes_ar <= 0 then
		printf("! [Raid] No stashes found on this location")
		return
	end

	return stashes_ar[math.random(1, #stashes_ar)]
end

function find_random_anomaly(level_name)
	local anomaly_ar = {}
	for i = 1, 65534 do
		local se_obj = alife_object(i)
		if se_obj and IsAnomaly(se_obj) then
			local anomaly_lid = game_graph():vertex(se_obj.m_game_vertex_id):level_id()
			local anomaly_lname = anomaly_lid and alife():level_name(anomaly_lid)
			if anomaly_lname and (anomaly_lname == level_name) then
				printf('anomaly id: %s', se_obj.id)
				anomaly_ar[#anomaly_ar + 1] = se_obj.id
			end
		end
	end

	if #anomaly_ar <= 0 then
		printf("! [Raid] No anomalies found on this location")
		return
	end

	return anomaly_ar[math.random(1, #anomaly_ar)]
end

function find_random_smart(level_name, busy_check, smart_amounts, item_spawn_check)
	local smarts_t = {}
--	printf("raid_utils.find_random_smart()")
	for sname, sm in pairs(SIMBOARD.smarts_by_names) do
		local smart_lid = game_graph():vertex(sm.m_game_vertex_id):level_id()
		local smart_lname = smart_lid and alife():level_name(smart_lid)
		local busy_smart = busy_check and smart_is_busy(sm.id) or false
		local block_smart = item_spawn_check and smarts_blacklist_for_items[sm:name()] or false
--		printf("    %s and %s", (not smart_lname and "! Not smart name") or (smart_lname == level_name and "- Smart is on this level") or "! Smart NOT on this level", busy_smart and "Busy" or "Free")
		if smart_lname and (not busy_smart) and smart_lname == level_name and (not smarts_blacklist[sm:name()]) and (not block_smart) then
			smarts_t[sm.id] = true
		end
	end

	if size_table(smarts_t) <= 0 then
		printf("! [Raid] No smarts found on this location")
		return
	end

	-- return 1 smart on this level
	if not smart_amounts then
		return random_key_table(smarts_t)
	end

	-- return all smarts on this level
	if smart_amounts == "all" then
		return smarts_t
	end

	-- return "x" smarts on this level
	local scout_smarts_t = {}
	for i = 1, smart_amounts do
		local random_id = random_key_table(smarts_t)
		-- check if smart busy by other scout tasks
		if random_id and (not raid_tasks_scout.scout_smart_busy(random_id)) then
			scout_smarts_t[random_id] = true
			smarts_t[random_id] = nil
		end
	end
	return size_table(scout_smarts_t) > 0 and scout_smarts_t
end

function find_viable_smart(smart_t, comm, surge_check, exclude_nearest)
	if not (smart_t and comm) then return end
	if comm == "duty" then comm = "dolg" end

	local viable_smarts_t = {}

	for smart_id, _ in pairs(smart_t) do
		local smart = alife_object(smart_id)
		if smart then
			local surge_prop = smart.props["surge"] and smart.props["surge"] > 0
			local sim_avail = simulation_objects.available_by_id[smart_id] and simulation_objects.available_by_id[smart_id] == true
			local smart_props = (smart.props[comm] and smart.props[comm] > 0) or (smart.props.all and smart.props.all > 0)
			local nearest_smart_id = exclude_nearest and smart_terrain.nearest_to_actor_smart.id and smart_terrain.nearest_to_actor_smart.id == smart.id or false
			if sim_avail and smart_props and (not nearest_smart_id) and (not smarts_blacklist[smart:name()]) then
				if (not surge_check) or surge_prop then
					viable_smarts_t[smart_id] = true
				end
			end
		end
	end

	if size_table(viable_smarts_t) <= 0 then
		printf("! [Raid] 2 No smarts found on this location")
		return
	end

	return alife_object(random_key_table(viable_smarts_t))
end

function find_event_patrol_smarts(level_name)
	-- collect all viable smarts and xz position
	local ev_smarts_t = {}
	for sname, sm in pairs(SIMBOARD.smarts_by_names) do
		local smart_lid = game_graph():vertex(sm.m_game_vertex_id):level_id()
		local smart_lname = smart_lid and alife():level_name(smart_lid)
		local busy_smart = smart_is_busy(sm.id)
		local sim_avail = simulation_objects.available_by_id[sm.id] and simulation_objects.available_by_id[sm.id] == true
		local nearest_smart_id = smart_terrain.nearest_to_actor_smart.id and smart_terrain.nearest_to_actor_smart.id == sm.id 
		if smart_lname and (not busy_smart) and smart_lname == level_name and sim_avail and (not nearest_smart_id) and (not smarts_blacklist[sm:name()]) then
			ev_smarts_t[sm.id] = {}
			ev_smarts_t[sm.id].x = sm.position.x
			ev_smarts_t[sm.id].z = sm.position.z
		end
	end

	-- get nearest to the edge smarts and pick one
	local start_smart_id

	local ar = { 1, 2, 3, 4 }
	for i = 1, #ar do
		local j = math.random(#ar)
		ar[i], ar[j] = ar[j], ar[i]
	end

	for i = 1, #ar do
		start_smart_id = furthest_xz_smart(ev_smarts_t, ar[i])
		if start_smart_id then
			break
		end
	end

	-- get furthest from picked
	local end_smart_id
	local start_smart = alife_object(start_smart_id)
	printf("raid_utils.find_event_patrol_smarts, 147 start_smart: %s", start_smart and start_smart.id)
	local dist = 0
	for sm_id, t in pairs(ev_smarts_t) do
		local sm_to = alife_object(sm_id)
		local dist_to = sm_to and sm_to.id ~= start_smart.id and start_smart.position:distance_to_xz(sm_to.position)
		if dist_to and dist_to > dist then
			end_smart_id = sm_to.id
		end
	end

	printf("raid_utils.find_event_patrol_smarts, 157 end_smart_id: %s", end_smart_id)
	return { start_smart_id, end_smart_id }
end

function furthest_xz_smart(smart_t, mode)
	local far_sm_id, mx, mz

	for sm_id, t in pairs(smart_t) do
		mx = mx or t.x
		mz = mz or t.z

		if (mode == 1 and mx < t.x and mz < t.z) or		-- bottom left
			(mode == 2 and mx < t.x and mz > t.z) or		-- top left
			(mode == 3 and mx > t.x and mz < t.z) or		-- bottom right
			(mode == 4 and mx > t.x and mz > t.z) then	-- top right
			mx = t.x
			mz = t.z
			far_sm_id = sm_id
		end
	end

	return far_sm_id
end

function get_kill_target_squad_sec(ar, tier)
	local def_sec = "raid_renegade_sim_squad_2"
	local enemies_ar = dup_table(ar)

	for i = 1, 12 do
		-- break if array already empty
		if #enemies_ar <= 0 then
			break
		end

		-- pick random comm
		local rnd_idx = math.random(1, #enemies_ar)
		local rnd_comm = rnd_idx and enemies_ar[rnd_idx]

		-- get squad sec according to tier
		local sec = rnd_comm and "raid_" .. rnd_comm .. "_sim_squad_" .. tier

		-- if section exists return it
		if sec and ini_sys:section_exist(sec) then
			return sec
		end

		-- if section does not exist remove this comm from array
		table.remove(enemies_ar, rnd_idx)
	end

	return def_sec
end

function spawn_guide_squad(sec)
	local pos, lvid, gvid = db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id()

	-- create squad
	local se_obj
	local squad = alife_create(sec, pos, lvid, gvid)
	if not squad then return end

	squad:create_npc(nil, pos, lvid, gvid)

	-- find commander
	for m in squad:squad_members() do
		if m.id == squad:commander_id() then
			se_obj = alife_object(m.id)
		end
	end
	if not se_obj then return end

	-- setup logic and stuff
	SIMBOARD:setup_squad_and_group(se_obj)

	-- delay for object to become online
	CreateTimeEvent("delay_raid_guide_e_" .. se_obj.id, "delay_raid_guide_a_" .. se_obj.id, 1, function(obj_id)
		local npc = level.object_by_id(obj_id)
		if npc then
			npc:set_relation(game_object.friend, db.actor)
			dialogs_axr_companion.become_actor_companion(db.actor, npc)
		end
		return true
	end, se_obj.id)

	return squad
end

function kill_task_cond(squad, se_obj, killer)
	if not (squad and se_obj and killer) then return end

	local actor_killer = killer.id == 0
	local anomaly_killer = IsAnomaly(killer)
	local self_killer = killer.id == se_obj.id
	local friendly_fire = obj_in_squad(killer.id, squad.id)
	local comp_killer = level.object_by_id(killer.id) and level.object_by_id(killer.id):has_info("npcx_is_companion")

	if actor_killer or anomaly_killer or self_killer or friendly_fire or comp_killer then
		return true
	end
end

function obj_in_squad(obj_id, squad_id)
	local squad = alife_object(squad_id)
	if squad and squad.commander_id then
		for m in squad:squad_members() do
			if m.id == obj_id then
				return true
			end
		end
	end
end

function get_squad_size(squad_id)
	local squad = alife_object(squad_id)
	local squad_size = 0
	if squad and squad.commander_id then
		for member in squad:squad_members() do
			local se_member = alife_object(member.id)
			if se_member and se_member:alive() then
				squad_size = squad_size + 1
			end
		end
	end

	return squad_size
end

function get_weapon_list()
	local ammo_ar = {
		"9x18", "9x19", "5.7x28", "7.62x25", "11.43x23", "5.45x39", "5.56x45",
		"9x39", "12x70", "12x76", "7.62x39", "7.92x33", "7.62x51", "pkm_100",
		"7.62x54", "12.7x55", "magnum_300", "357_hp",
	}

	return ammo_ar[math.random(1, #ammo_ar)]
end

function get_armor_list(ret_comm)
	local t = {}

	local outf_str = { "(Light)", "(Medium)", "(Heavy)" }

	for _, name in ipairs(outf_str) do
		local outf_ar = ui_debug_main.get_spawn_table("Outfits " .. name)
		for __, sec in pairs(outf_ar) do
			local comm = ini_sys:r_string_ex(sec, "community")
			if comm and (not t[comm]) then
				t[comm] = true
			end
		end
	end

	if ret_comm then
		return random_key_table(t)
	end

	return t
end

function make_group_universal(strR)  -- Rojok. Fix for mod Artefact Renovation
	local countR = 0
	local positionR = 0

	-- We are looking for the third symbol "_"
	for i = 1, #strR do
		positionR = string.find(strR, "_", positionR + 1)
		if positionR then
			countR = countR + 1
			if countR == 3 then
				break
			end
		else
			break
		end
	end
		
	-- Cut the string to the third "_"
	if positionR then
		strR = string.sub(strR, 1, positionR - 1)
	end
	
	return strR
end
function get_artefact_list(ret_group, ret_art)
	local t = utils_data.collect_section(art_ini, "artefact_groups", true)

	-- remove junk
	for group, _ in pairs(t) do
		if string.find(group, "_musor") then
			t[group] = nil
		end
	end

	-- pick random group
	local group = random_key_table(t)
	if ret_group then
		return make_group_universal(group)
	end

	-- pick random artefact
	local group_t = utils_data.collect_section(art_ini, group, true)
	if ret_art then
		return random_key_table(group_t)
	end

	return t
end

function get_artefact_group(art_sec)
	local t = utils_data.collect_section(art_ini, "artefact_groups", true)

	-- find this art in all groups
	for group, _ in pairs(t) do
		local group_t = utils_data.collect_section(art_ini, group, true)
		if group_t[art_sec] then
			return make_group_universal(group)
		end
	end
end

function get_translated_group_string(group, typ)
	local str = ""
	local pref_str = ""
	if not group then
		return str
	end

	str = " ("

	if typ == "find_outfit" then
		pref_str = gt("st_faction_" .. group)
	elseif group and to_translate[group] then
		pref_str = gt("st_raid_task_" .. group)
	else
		pref_str = group
	end

	return str .. pref_str .. ")"
end

function get_tasks_on_level(lname)
	local tasks_num = 0
	for task_id, t in pairs(raid_tasks_main.raid_active_tasks) do
		if t.level_name and t.level_name == lname then
			tasks_num = tasks_num + 1
		end
	end
	return tasks_num
end

item_groups_t = {}
item_by_tier_t = {}
function collect_and_group_items()
	if not (is_empty(item_groups_t)) then return end

	local ltx = ini_file("plugins\\spawner_blacklist.ltx")
	ini_sys:section_for_each(function(sec)
		if (not ltx:line_exist("ignore_sections", sec))
		and (not string.find(sec, "tch_"))
		and (not string.find(sec, "mp_"))
		and (not string.find(sec, "_base"))
		and (not string.find(sec, "pn23"))
		and (not raid_tables.reward_blacklist_items_t[sec])
		and (ini_sys:r_string_ex(sec, "inv_name_short") and ini_sys:r_string_ex(sec, "inv_name")) 
		then
			local kind = ini_sys:r_string_ex(sec, "kind")
			local group = raid_tables.itms_t[sec] or (kind and raid_tables.kind_t[kind])
			if group then
				item_groups_t[group] = item_groups_t[group] or {}
				local cost = ini_sys:r_float_ex(sec, "cost") or 0
				item_groups_t[group][sec] = cost
			end
		end
	end)

	divide_items_by_tier()
end

function divide_items_by_tier()
	for group, sec_t in pairs(item_groups_t) do
		item_by_tier_t[group] = item_by_tier_t[group] or {}

		-- sort
		for k, v in pairs(sec_t) do
			local price = raid_tables.tiers_by_price[group]
			local tier = 1
			if (price and v > price[1]) then tier = 2 end
			if (price and v > price[2]) then tier = 3 end			
			if (price and v > price[3]) then tier = 4 end			
			
			item_by_tier_t[group][tier] = item_by_tier_t[group][tier] or {}
			table.insert(item_by_tier_t[group][tier], k)			
		end	
	end

end

function get_task_reward(comm, task_t, special_reward)

	-- special reward
	if special_reward then
		return raid_tables.task_special_reward[task_t.typ]
	end

	-- scout reward scaling
	-- local scout_rew_mult = task_t.typ == "scout" and (0.5*task_t.tier+0.5) or 1

	-- normal reward
	local rew_mult = raid_tables.task_reward_mults[task_t.typ]
	local urgency_val = task_t.urgent < 4 and raid_tables.task_urgency_reward[task_t.urgent] or 0
	local range_money = math.random(-raid_tables.base_task_money_range, raid_tables.base_task_money_range)
	-- local money = raid_tables.base_task_money * (rew_mult + task_t.tier +  urgency_val) * scout_rew_mult + math.ceil(range_money)
	local money = math.ceil(raid_tables.base_task_money * (rew_mult * 7 + ((task_t.tier + 0.5) ^ 2.75) + (urgency_val * task_t.tier)) + math.ceil(range_money))
	local rank = math.ceil(raid_tables.base_task_rank * rew_mult + (task_t.tier * 5))
	local goodwill = raid_tables.base_task_goodwill * task_t.tier
	local goodwill_penalty
	if comm == "other" then
		money = math.floor(money * raid_tables.other_money_mult)
		goodwill_penalty = raid_tables.other_goodwill_penalty
	end

	-- check items
	local items = {}
	local new_money, items_ar = get_task_reward_items(comm, task_t.tier, money)
	if new_money and items_ar then
		items = items_ar
		money = new_money
	end

	return { items = items, money = money, rank = rank, goodwill = goodwill, goodwill_penalty = goodwill_penalty }
end

function get_task_reward_items(comm, tier, money)				
	local reward_t = raid_tables.reward_items_t[tier]
	if math.random(100) > reward_t.chance or comm == "other" then return end

	local items_money = money * ((reward_t.sum + math.random(-10, 10)) / 100)
	local new_money = math.floor(money - items_money)

	local items_list = {}

	-- first pick one main item
	for i = 1, 15 do
		-- pick random main item group
		local group = random_key_table(reward_t.main_items)			
		for i = 1, 5 do
			if reward_t.main_items[group][5] and (math.random(1, 100) >= reward_t.main_items[group][5]) then
				group = random_key_table(reward_t.main_items)
			else
				break
			end
		end
		
		-- try to set higher tier for this reward
		local rnd = math.random(100)
		local tier_r = 1
		if rnd <= reward_t.main_items[group][4] then
			tier_r = 4
		elseif rnd <= (reward_t.main_items[group][4] + reward_t.main_items[group][3]) then
			tier_r = 3
		elseif rnd <= (reward_t.main_items[group][4] + reward_t.main_items[group][3] + reward_t.main_items[group][2]) then
			tier_r = 2
		end

		local new_cost
		local item_sec
		for i = 1, 7 do
			-- pick list of this items tier
			local items_ar = group and item_by_tier_t[group] and item_by_tier_t[group][tier_r]
			-- pick random section
			item_sec = items_ar and items_ar[math.random(1, #items_ar)]
			-- get item cost and divide it by table divider
			local cost = item_sec and ini_sys:r_float_ex(item_sec, "cost")
			new_cost = cost and cost / (reward_t.div + (math.random() * 0.6 - 0.3))
			if new_cost and new_cost < items_money and (not raid_tables.reward_blacklist_items_t[item_sec]) then break end
		end
		
		-- if we still have enough items money then add item sec to list and sub new_cost
		if new_cost and new_cost < items_money and (not raid_tables.reward_blacklist_items_t[item_sec]) then
			items_list[#items_list + 1] = item_sec
			items_money = items_money - new_cost
			break
		end
	end


	-- then pick secondary items
	for i = 1, 100 do
		-- pick random item group and section
		local group = reward_t.items[math.random(1, #reward_t.items)]
		local item_sec = group and item_groups_t[group] and random_key_table(item_groups_t[group])
		-- get item cost
		local cost = item_sec and ini_sys:r_float_ex(item_sec, "cost")
		-- if we still have enough items money then add item sec to list and sub cost
		if cost and cost < items_money and (not raid_tables.reward_blacklist_items_t[item_sec]) then
			items_list[#items_list + 1] = item_sec
			items_money = items_money - cost
		end
	end

	-- if list is empty then return
	if #items_list <= 0 then return end

	-- return new_money and items list
	return new_money, items_list
end

function give_task_reward(task_t, comm, task_id)
	if task_t.reward then
		if #task_t.reward.items > 0 then
			local inv_box = get_story_object("raid_shelter_box_2")
			for idx, sec in ipairs(task_t.reward.items) do
			--	alife_create_item(sec, db.actor)
				alife_create_item(sec, inv_box)
			end
		end
		db.actor:give_money(task_t.reward.money)
		game_statistics.increment_rank(task_t.reward.rank)
		raid_tasks_main.raid_tasks_t[comm].goodwill = raid_tasks_main.raid_tasks_t[comm].goodwill + task_t.reward.goodwill
		if raid_tasks_main.raid_tasks_t[comm].goodwill > raid_tables.max_goodwill then
			raid_tasks_main.raid_tasks_t[comm].goodwill = raid_tables.max_goodwill
		end

		-- decrease for others
		if task_t.reward.goodwill_penalty then
			for k, t in pairs(raid_tasks_main.raid_tasks_t) do
				if k ~= comm then
					raid_tasks_main.raid_tasks_t[k].goodwill = raid_tasks_main.raid_tasks_t[k].goodwill + task_t.reward.goodwill_penalty
					if raid_tasks_main.raid_tasks_t[k].goodwill < raid_tables.min_goodwill then
						raid_tasks_main.raid_tasks_t[k].goodwill = raid_tables.min_goodwill
					end
				end
			end
		end

		task_reward_news(task_t.typ, task_t.reward.money, task_t.reward.items, task_t.reward.rank, task_t.reward.goodwill, comm, task_t.reward.goodwill_penalty)

	elseif task_t.special_reward_mult and raid_tasks_main.raid_active_tasks[task_id].found_item_id then
		local item = level.object_by_id(raid_tasks_main.raid_active_tasks[task_id].found_item_id)
		local item_cost = item and ini_sys:r_float_ex(item:section(), "cost") or 0
		local item_cond = item and item.condition and item:condition() or 1
		local tot_money = math.ceil(task_t.special_reward_mult * item_cost * item_cond)

		db.actor:give_money(tot_money)

		task_reward_news(task_t.typ, tot_money)
	end

end

function task_reward_news(task_typ, money, items_ar, rank, goodwill, comm, goodwill_penalty)
	local str = ""

	-- Reward title
	if task_typ then
		str = str .. gt("st_raid_reward_news") .. " " .. gt("st_raid_task_" .. task_typ) .. ": \\n"
	end

	-- items
	if items_ar and #items_ar > 0 then
		str = str .. gt("st_raid_krug") .. " " .. gt("st_raid_task_title_reward_items") .. "   "		-- Items:
		for idx, sec in ipairs(items_ar) do
			local inv_name = ini_sys:r_string_ex(sec, "inv_name_short") or ini_sys:r_string_ex(sec, "inv_name") or "ERROR"
			str = str .. gt(inv_name) .. (idx == #items_ar and " \\n" or " + ")		-- list of items
		end
	end

	-- money
	if money then
		str = str .. gt("st_raid_krug") .. " " .. gt("st_raid_task_title_reward_money") .. "   " .. money .. " " .. gt("st_rubles") .. " \\n"		-- Money: money rub
	end

	-- rank
	if rank then
		local sign = rank > 0 and "+" or ""
		str = str .. gt("st_raid_krug") .. " " .. gt("ui_st_rank") .. ":   " .. sign .. rank .. " \\n"		-- Rank: rank
	end

	-- goodwill
	if goodwill and comm then
		if comm == "duty" then comm = "dolg" end
		local sign = goodwill > 0 and "+" or ""
		str = str .. gt("st_raid_krug") .. " " .. gt("st_raid_task_title_reward_goodwill") .. "   " .. sign .. goodwill .. " (" .. gt("st_faction_" .. comm) .. ") \\n"		-- Goodwill: goodwill (comm)
	end

	-- goodwill penalty
	if goodwill_penalty then
		str = str .. gt("st_raid_krug") .. " " .. gt("st_raid_task_title_reward_goodwill_penalty") .. "   " .. goodwill_penalty
	end

	-- send msg
	news_manager.send_tip(db.actor, str, 3, nil, 15000)
end

-- news manager patch, очередная очень важная хуйня
local action_descr_by_type = {
	new = "general_new_task",
	complete = "general_complete_task",
	fail = "general_fail_task",
	reversed = "general_reverse_task",
	updated = "general_update_task"
}

function news_manager.send_task(actor, typ, tsk)
	local tm = task_manager.get_task_manager()
	local id = tsk:get_id()

	local rtask = tm.task_info[id]
	if typ == "fail" and rtask and rtask.cancelled_by_actor then
		typ = "reversed"
	end

	if db.actor == nil then
		return false
	end
	local time_on_screen = (typ == "updated") and 5000 or 10000
	if typ ~= "updated" then
		xr_sound.set_sound_play(AC_ID, "pda_task")
	end
	local news_caption = game.translate_string(action_descr_by_type[typ])
	local news_text = game.translate_string(tsk:get_title() or "")
	local icon = tsk:get_icon_name()
	if(icon==nil) then
		icon = "ui_iconsTotal_storyline"
	end

	if db.actor:is_talking() then
		db.actor:give_talk_message2(news_caption, news_text..".", icon, "iconed_answer_item")
		return
	end

	-- fail and complete are handled by func below
	if typ == "fail" or typ == "complete" then
		return
	end

	-- if task already cancelled dont send anything
	local task_active = false
	for comm, t in pairs(raid_tasks_main.raid_tasks_t) do
		if t.tasks[id] then
			task_active = true
			break
		end
	end

	if task_active then
		db.actor:give_game_news(news_caption, news_text..".", icon, 0, time_on_screen)
	end
end

function raid_send_task_msg(task_t, typ)
	if db.actor == nil then return false end

	local time_on_screen = 10000
--	xr_sound.set_sound_play(AC_ID, "pda_task")		-- overriden by func above probably
	local news_caption = gt(action_descr_by_type[typ])
	local news_text = gt("st_raid_task_" .. task_t.typ)
	local icon = "ui_icon_news_trx_death_report"

	db.actor:give_game_news(news_caption, news_text..".", icon, 2000, time_on_screen)
end
-------------------------------------------------------------------

function give_task_penalty(comm, task_id)
	local num = raid_tables.base_task_fail_goodwill
	if (string.find(task_id, "_find_")) then num = raid_tables.base_task_find_fail_goodwill end
	raid_tasks_main.raid_tasks_t[comm].goodwill = raid_tasks_main.raid_tasks_t[comm].goodwill + num
	if raid_tasks_main.raid_tasks_t[comm].goodwill < raid_tables.min_goodwill then
		raid_tasks_main.raid_tasks_t[comm].goodwill = raid_tables.min_goodwill
	end
end

function get_item_group(sec)
	for group, sec_t in pairs(item_groups_t) do
		if sec_t[sec] then
			return group
		end
	end
	return nil
end

function get_reward_items_string(items_ar, main_item, for_details_wnd)
	if #items_ar <= 0 then
		return ""
	end

	local def_clr = strformat("%c[%s,%s,%s,%s]", 255, 190, 190, 190)
	local yel_clr  = utils_xml.get_color("yellow")
	local grey_clr = strformat("%c[%s,%s,%s,%s]", 255, 210, 210, 210)

	if for_details_wnd then
		def_clr = strformat("%c[%s,%s,%s,%s]", 255, 45, 45, 45)
	end

	local str = ""
	for idx, sec in ipairs(items_ar) do
		if main_item then
			local group = get_item_group(sec)
			if group then
				str = " \\n" .. gt("st_raid_task_title_reward_items") .. " " .. yel_clr .. gt("st_raid_task_" .. group) .. def_clr
				return str
			end
			return ""
		else
			local inv_name = ini_sys:r_string_ex(sec, "inv_name_short") or ini_sys:r_string_ex(sec, "inv_name") or "ERROR"
			if idx == 1 then	-- first item
				str = " \\n" .. gt("st_raid_task_title_reward_items") .. " " .. yel_clr .. gt(inv_name) .. grey_clr
			else		-- other items
				str = str .. " + " .. gt(inv_name)
			end
		end
	end

	return str .. def_clr
end

function get_raid_task_title(task_id, stage, stage_max, special)
	local task_data = raid_tasks_main.get_task_data(task_id)
	if not task_data then
		return ""
	end

	if not (stage and stage_max) then
		return gt(task_data.typ .. ": no stage error")
	end

	if stage >= stage_max then
		return gt("st_raid_task_" .. task_data.typ)
	end

	local hours_left_str = ""
	local max_time = task_data.urgent and raid_tables.raid_urgency_time[task_data.urgent]
	local active_t = raid_tasks_main.raid_active_tasks[task_id]
	if max_time and active_t and active_t.start_time then
		local hours_passed = round(game.get_game_time():diffSec(t_to_ctime(active_t.start_time)) / 3600)
		hours_left_str = "  [" .. max_time - hours_passed .. " " .. gt("st_raid_hours") .. "]"
	end

	if special and task_data.group then		-- find certain item tasks
		return gt("st_raid_task_" .. task_data.typ .. "_short_descr") .. get_translated_group_string(task_data.group, task_data.typ) .. hours_left_str
	end
	
	if string.find(task_data.typ, "rf_scout_and_delivery_out") or false then 
		local freq = task_data.target_freq

		return strformat(gt("st_raid_task_" .. task_data.typ) .. hours_left_str, freq)
	end

	return gt("st_raid_task_" .. task_data.typ) .. hours_left_str
end

function get_raid_task_descr(task_id, stage, stage_max, special)
	local task_data = raid_tasks_main.get_task_data(task_id)
	if not task_data then
		return ""
	end

	if not (stage and stage_max) then
		return gt(task_data.typ .. ": no stage error")
	end

	if special and task_data.group then		-- find certain item tasks
		return gt("st_raid_task_" .. task_data.typ .. "_short_descr") .. get_translated_group_string(task_data.group, task_data.typ)
	end

	if stage < stage_max then
		-- special case for people who accidentally put item in wrong stash and then target is this stash (which is actually item that they need to pick)
		if task_data.typ == "delivery_in" and stage == 2 then
			return gt("st_raid_task_" .. task_data.typ .. "_short_descr_2")
		end
		return gt("st_raid_task_" .. task_data.typ .. "_short_descr")
	end

	return gt("st_raid_task_return")
end

function raid_change_goodwill(comm, val)
	raid_tasks_main.raid_tasks_t[comm].goodwill = raid_tasks_main.raid_tasks_t[comm].goodwill + val
	if raid_tasks_main.raid_tasks_t[comm].goodwill < raid_tables.min_goodwill then
		raid_tasks_main.raid_tasks_t[comm].goodwill = raid_tables.min_goodwill
	end
	if raid_tasks_main.raid_tasks_t[comm].goodwill > raid_tables.max_goodwill then
		raid_tasks_main.raid_tasks_t[comm].goodwill = raid_tables.max_goodwill
	end
end

function create_event_item(sec, obj_id)
	if not obj_id then return end
	CreateTimeEvent("create_event_item_e_" .. obj_id, "create_event_item_a_" .. obj_id, 1, function(id)
		local se_obj = alife_object(id)
		if se_obj then
			alife_create_item(sec .. "_raid_event_item", se_obj)
		end
		return true
	end, obj_id)
end

function unpack_event_item(obj)
	local sec = obj:section()
	local comm = string.gsub(sec, "_raid_event_item", "")

	local package_sec = (comm == "ecolog" and "medkit_ai" .. math.random(1, 3)) or ("quest_package_" .. math.random(1, 8))

	local content = parse_list(itms_manager.ini_manager, "package_content", package_sec)
	if #content > 0 then
		utils_item.delay_event(content, {obj:id()}, "package_content", false, 5)
	end

	-- hit goodwill
	raid_change_goodwill(comm, -120)
end

function align_element(gui, elem, cont, h, v, text_h, text_v)
--	align_element(self, self.elem, self.cont, "c", "b")			is element bottom center
--	align_element(self, self.elem, nil, nil, nil, 1, 2)				is text bottom center (i think xd)

	if not (gui and elem) then return end

	if h and type(h) == "string" and cont then
		local elem_w = elem:GetWidth()
		local cont_w = cont:GetWidth()

		if (elem_w <= cont_w) then
			local horiz_align

			if h == "l" then
				horiz_align = 0
			elseif h == "r" then
				horiz_align = cont_w - elem_w
			elseif h == "c" then
				horiz_align = (cont_w - elem_w) / 2
			end

			if horiz_align then
				local elem_pos = elem:GetWndPos()
				elem:SetWndPos(vector2():set(horiz_align, elem_pos.y))
			end
		end
	end


	if v and type(v) == "string" and cont then
		local elem_h = elem:GetHeight()
		local cont_h = cont:GetHeight()

		if (elem_h <= cont_h) then
			local vert_align

			if v == "t" then
				vert_align = 0
			elseif v == "b" then
				vert_align = cont_h - elem_h
			elseif v == "c" then
				vert_align = (cont_h - elem_h) / 2
			end

			if vert_align then
				local elem_pos = elem:GetWndPos()
				elem:SetWndPos(vector2():set(elem_pos.x, vert_align))
			end
		end
	end

	if text_h and type(text_h) == "number" and text_h < 3 then
		elem:SetTextAlignment(text_h)
	end

	if text_v and type(text_v) == "number" and text_h < 3 then
		elem:SetVTextAlignment(text_v)
	end

end

local rank_idx_t = {
	novice = 1, trainee = 2, experienced = 3, professional = 4,
	veteran = 5, expert = 6, master = 7, legend = 8
}

function get_actor_rank_name(ret_idx)
	local actor_rank = ranks.get_obj_rank_name(db.actor)
	return ret_idx and rank_idx_t[actor_rank] or actor_rank
end

function get_actor_rank_val()
	return db.actor.character_rank and db.actor:character_rank() or db.actor.rank and db.actor:rank()
end

function get_rank_val_ar()
	local str = ini_sys:r_string_ex("game_relations", "rating")
	local p = str and str_explode(str, ",")

	local ar = {}
	for i = 1, #p do
		local n = tonumber(p[i])
		if type(n) ~= "number" then		-- name
			ar[#ar + 1] = {}
			ar[#ar][1] = p[i]

			local prev_v = p[i - 1]
			ar[#ar][2] = prev_v or 0

			local next_v = p[i + 1]
			ar[#ar][3] = next_v or 999999
		end
	end

	return ar
end

function get_val_by_rank(rank, next_val)
	local ar = get_rank_val_ar()
	for i = 1, #ar do
		if ar[i][1] == rank then
			return next_val and ar[i][3] or ar[i][2]
		end
	end
end

function calc_raid_time(ret_mins)
	local bonus = 0
	if HI("raid_upgrade_clock") then
		bonus = bonus + 5
	end
	if HI("raid_upgrade_btr") then
		bonus = bonus + 10
	end
	if HI("raid_upgrade_heli") then
		bonus = bonus + 20
	end
	if HI("raid_informator_raid_time") then
		bonus = bonus + raid_tables.informant_bonus_raid_time
	end

	bonus = bonus * 60
	return ret_mins and round((raid_tables.raid_raid_time + bonus) / 60) or raid_tables.raid_raid_time + bonus
end

function calc_travel_time(hrs)
	local btr_time = HI("raid_upgrade_btr") and raid_tables.raid_btr_travel_time_mult or 1
	local heli_time = HI("raid_upgrade_heli") and raid_tables.raid_heli_travel_time_mult or 1

	return hrs * btr_time * heli_time
end

function calc_survive_chance()
	local def_chance = raid_tables.raid_survive_chance or 0
	local pill_chance = db.actor:object("pill_raid") and raid_tables.raid_survive_pill or 0
	local pda_3_chance = db.actor:object("device_pda_3") and raid_tables.raid_survive_pda_3
	local pda_2_chance = db.actor:object("device_pda_2") and raid_tables.raid_survive_pda_2

	return def_chance + pill_chance + (pda_3_chance or pda_2_chance or 0)
end

function reset_raid_time_info_portions()
	if HI("raid_upgrade_btr") then
		DI("raid_upgrade_btr")
	end
	if HI("raid_upgrade_heli") then
		DI("raid_upgrade_heli")
	end
	if HI("raid_informator_raid_time") then
		DI("raid_informator_raid_time")
	end
end

function level_exist(level_name)
	local lvl_ini = ini_file("ai_tweaks\\simulation_objects.ltx")
	if lvl_ini:section_exist(level_name) then
		return true
	end
end

function change_lc_restrictors_hint()
	local sr_teleport_ini = ini_file("sr_teleport_sections.ltx")
	for i = 1, 65534 do
		local se_obj = alife_object(i)
		if se_obj and se_obj:clsid() == clsid.script_restr and se_obj:section_name() == "space_restrictor" and sr_teleport_ini:section_exist(se_obj:name()) then
			local spot = sr_teleport_ini:line_exist(se_obj:name(), "spot") and sr_teleport_ini:r_string_ex(se_obj:name(), "spot")
			if spot then
				level.map_change_spot_hint(se_obj.id, spot, "st_raid_new_lc_hint")
			end
		end
	end
end

function raid_get_actor_rad_prot()
	local outfit = db.actor:item_in_slot(7)
	local c_outfit = outfit and outfit:cast_CustomOutfit()
	local outf_prot = c_outfit and c_outfit:GetDefHitTypeProtection(HitTypeID["Radiation"]) or 0

	local helmet = db.actor:item_in_slot(12)
	local c_helmet = helmet and helmet:cast_Helmet()
	local helm_prot = c_helmet and c_helmet:GetDefHitTypeProtection(HitTypeID["Radiation"]) or 0

	local arte_prot = 0
	db.actor:iterate_belt( function(owner, item)
		local item_prot_sec = SYS_GetParam(0, item:section(), "hit_absorbation_sect")
		local item_prot = item_prot_sec and SYS_GetParam(2, item_prot_sec, "radiation_protection", 0) or 0
		arte_prot = arte_prot + item_prot
	end)

	local boost_prot = 0
    db.actor:cast_Actor():conditions():BoosterForEach( function(booster_type, booster_time, booster_value)
        if booster_type == 5 then
            boost_prot = booster_value
        end
    end)

	return outf_prot + helm_prot + arte_prot + boost_prot
end

function raid_get_rad_hit(hours)
	local hour = 0
	if (hours ~= nil) then hour = hours end
	
	local sum_radiation_speed = 0
	db.actor:iterate_inventory( function(owner, obj)
		if (IsArtefact(obj)) then
			local sec = obj:section()
			sum_radiation_speed  = sum_radiation_speed + SYS_GetParam(2, sec, "radiation_restore_speed", 0)
		end
	end)
	
	local hit_from_artifacts = (sum_radiation_speed * 100000) * math.sqrt(hour) * raid_tables.raid_hit_from_artifacts_mult
	local hit_accumulated_radiation = (db.actor.radiation * 3870 / 10) * raid_tables.raid_hit_accumulated_radiation_mult
	local rad_hit = (hit_from_artifacts + hit_accumulated_radiation) / 100

	return rad_hit or 0
end

function raid_send_info(news_caption, news_text, texture_name, showtime, texture_master)
	local texture = "ui_iconsTotal_grouping"
	if (texture_name ~= nil) then
		if type(texture_name) == "string" then
			if tips_icons[texture_name] then
				texture = tips_icons[texture_name]
			end
		end
	end
	if (texture_master ~= nil) then texture = texture_master end
	
	db.actor:give_game_news(news_caption, news_text, texture, 0, showtime)
	
	xr_sound.set_sound_play(AC_ID, "pda_tips")
end								
function get_equipped_items()
	local t = {}
	for i = 1, 13 do
		local itm = db.actor:item_in_slot(i)
		if i ~= 6 and i ~= 8 and i ~= 5 and i ~= 4 and itm then --5 Binocular --6 Bolt --8 PDA --4 Grenade
			t[itm:id()] = true
		end
	end
	return t
end

function get_equipped_items_with_belt()
    local t = {}
    for i = 1, 13 do
        local itm = db.actor:item_in_slot(i)
        if i ~= 6 and i ~= 8 and i ~= 5 and i ~= 4 and itm then --5 Binocular --6 Bolt --8 PDA --4 Grenade
            if itm:cost() > 2100 then
                t[itm:id()] = true
            end
        end
    end
    db.actor:iterate_belt( function(owner, itm)
        if (itm ~= nil) then
            if itm:cost() > 2100 then
                t[itm:id()] = true
            end            
        end
    end)
    return t
end

function get_pdas_in_inv()
	local pdas = {}
    local cost_mult = { ["itm_pda_common"] = 1, ["itm_pda_uncommon"] = 2, ["itm_pda_rare"] = 3 }

	local cost_min = raid_tables.informant_bonus_sell_pda_min
	local cost_max = raid_tables.informant_bonus_sell_pda_max

	db.actor:iterate_inventory(function(tmp, item)
		local sec = item:section()
		if cost_mult[sec] then
			pdas[item:id()] = math.random(cost_min, cost_max) * cost_mult[sec]
		end
	end, db.actor)

	if is_empty(pdas) then
		return
	end

	return pdas
end

function raid_get_cooldown()
	local cur_time = game.get_game_time()

	local task_cd = raid_tasks_main.reset_time
	local task_s = task_cd and (raid_tables.task_reset_cooldown - cur_time:diffSec(t_to_ctime(task_cd)))
	local task_h = task_s and math.ceil(task_s / 3600)

	local event_cd = raid_events.reset_time
	local event_s = event_cd and (raid_tables.event_reset_cooldown - cur_time:diffSec(t_to_ctime(event_cd)))
	local event_h = event_s and math.ceil(event_s / 3600)

	--Rojok. For treasures
	if (treasure_manager.flagConnection ~= nil) then
		return strformat(string.format(gt("st_raid_nimble_cooldown_answer_with_treasures"), task_h, event_h))	
	end
	
	return strformat(game.translate_string("st_raid_nimble_cooldown_answer"), task_h, event_h)
end

function in_ar(ar, val)
	for i = 1, #ar do
		if ar[i] == val then
			return true
		end
	end
end

function raid_misc_first_update()
	-- change all game statistics rank gain to 0
	for k, _ in pairs(game_statistics.actor_statistics) do
		game_statistics.actor_statistics[k].rank = 0
	end

	-- change level changer restrictors name
	change_lc_restrictors_hint()

	-- remove sidorovich and welcome first messages
	if not (has_alife_info("drx_sl_start_news")) then
		give_info("drx_sl_start_news")
	end
	if not (has_alife_info("trx_dynamic_news_welcome_to_network")) then
		give_info("trx_dynamic_news_welcome_to_network")
	end

end

function test_reward_func()
--	local check_ar = { "pistol", "smg", "shotgun", "rifle", "sniper", "o_light", "o_medium", "o_sci", "o_heavy" }

	local mode = 0

	if mode == 1 then
		for group, tier_ar in pairs(item_by_tier_t) do
			printf("    ")
			printf("---------------------------------------------------")
			printf("------------- group: %s ------------", group)

			for tier, sec_ar in pairs(tier_ar) do
				printf("      tier: %s", tier)
				for j = 1, #sec_ar do
					local cost = ini_sys:r_float_ex(sec_ar[j], "cost") or "nan"
					printf("            %s (%s)    ||    cost: %s  (divided: %s)", gt(ini_sys:r_string_ex(sec_ar[j], "inv_name_short")), sec_ar[j], cost, math.floor(cost / reward_items_t[tier].div))
				end
			end

			printf("---------------------------------------------------")
		end
	end

	if mode == 2 then
		for i = 1, 50 do
			local rnd_tier = math.random(1, 3)
			local rnd_money = rnd_tier * ( 12000 + (math.random(-3000, 3000)) )
			local money, items_list = get_task_reward_items(rnd_tier, rnd_money)
			if money and items_list then

				printf("    ")
				printf("---------------------------------------------------")
				printf("--------- Tier: %s || Money: %s ---------", rnd_tier, rnd_money)

				if items_list[1] then
					printf("    Main Item: %s (%s) || Cost: %s", gt(ini_sys:r_string_ex(items_list[1], "inv_name_short")), items_list[1], ini_sys:r_float_ex(items_list[1], "cost"))
				end

				printf("    ")

				local str = ""
				for j = 2, #items_list do
					local sec = items_list[j]
					local inv_name = gt(ini_sys:r_string_ex(items_list[j], "inv_name_short"))
					str = str ~= "" and (str .. ", ") or ""
					str = str .. inv_name .. " (" .. sec .. ")"
				end

				printf("    Secondary items: %s", str)

				printf("    ")

				printf("    Money left (Reward as money): %s", money)
				printf("---------------------------------------------------")

			end
		end
	end

end

function on_game_start()
	RegisterScriptCallback("on_game_load", collect_and_group_items)
	RegisterScriptCallback("actor_on_first_update", test_func)
end