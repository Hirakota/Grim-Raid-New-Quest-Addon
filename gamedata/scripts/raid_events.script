-- event npcs spawn and release with simulation in "raid_simulation.script" to control the order

raid_active_events = {}
--[[
	raid_active_events = {
		<level_name> = {
			-- random amount of events:
				-- "event" is event_name from "events_t",
				-- "opened" is for GUI
				-- "modified" is bonus for some events from informator
				-- "fake" is fake event, does not spawn anything
			[1] = { event = <event_name>, tier = <level_tier>, opened = <true/false>, modified = <"active"/"disabled"/nil>, fake = <true/false> },
			[2] = { ... },
		}
	}
--]]

raid_event_squads = {}
raid_event_busy_smarts_t = {}

local events_amount_t = {
	-- [level_tier] = { min, max }
	[1] = { 1, 2 },		[2] = { 2, 3 },		[3] = { 2, 4 },		[4] = { 3, 4 }
}

events_t = {
	-- [event_name] = { tiers }
	["rad_1"] = {
		tiers = { 1, 2, 3 },
		exclude = { "rad_2" },
		func = "rad_wind_ev",
	},

	["rad_2"] = {
		tiers = { 2, 3, 4 },
		exclude = { "rad_1" },
		func = "rad_hurricane_ev",
	},

	["raid_army"] = {
		tiers = { 1, 2, 3 },
		exclude = { "raid_merc", "raid_stalker", "raid_bandit" },
		func = "raid_army_ev",
		mod = 10000,
	},

	["raid_merc"] = {
		tiers = { 2, 3, 4 },
		exclude = { "raid_army", "raid_stalker", "raid_bandit" },
		func = "raid_merc_ev",
		mod = 30000,
	},

	["raid_stalker"] = {
		tiers = { 1, 2, 3 },
		exclude = { "raid_merc", "raid_army", "raid_sci" },
		func = "raid_stalker_ev",
	},

	["raid_mono"] = {
		tiers = { 3, 4 },
		exclude = {},
		func = "raid_mono_ev",
	},

	["raid_bandit"] = {
		tiers = { 1, 2, 3 },
		exclude = { "raid_merc", "raid_army", "raid_sci" },
		func = "raid_bandit_ev",
		mod = 5000,
	},

	["raid_sci"] = {
		tiers = { 1, 2, 3 },
		exclude = { "raid_stalker", "raid_bandit" },
		func = "raid_sci_ev",
	},

	["raid_csky"] = {
		tiers = { 1, 2 },
		exclude = {},
		func = "raid_csky_ev",
	},

	["runner"] = {
		tiers = { 1, 2, 3 },
		exclude = { "raid_army", "raid_merc", "raid_stalker", "raid_sci" },
		func = "raid_runner_ev",
	},

	["predators"] = {
		tiers = { 2, 3 },
		exclude = { "mutants" },
		func = "predators_ev",
	},

	["dog"] = {
		tiers = { 1, 2 },
		exclude = { "mutants" },
		func = "dog_ev",
	},

	["lurker"] = {
		tiers = { 2, 3 },
		exclude = { "mutants" },
		func = "lurker_ev",
	},

	["contoller"] = {
		tiers = { 2, 3 },
		exclude = {},
		func = "controller_ev",
	},

	["burer"] = {
		tiers = { 2, 3, 4 },
		exclude = {},
		func = "burer_ev",
	},

	["hunt"] = {
		tiers = { 3, 4 },
		exclude = { "mutants" },
		func = "hunt_ev",
	},

	["mutants"] = {
		tiers = { 1, 2, 3, 4 },
		exclude = { "predators", "dog", "lurker", "hunt" },
		func = "mutants_ev",
	},

	["psi_horde"] = {
		tiers = { 3, 4 },
		exclude = {},
		func = "psi_horde_ev",
	},

	["giant"] = {
		tiers = { 3, 4 },
		exclude = {},
		func = "giant_ev",
	},

}

reset_time = false
local cur_level
local ctime_to_t = utils_data.CTime_to_table
local t_to_ctime = utils_data.CTime_from_table

function generate_events()

	-- to reset info portions 
	raid_end_events()

	-- reset timer
	reset_time = ctime_to_t(game.get_game_time())

	-- reset events
	empty_table(raid_active_events)

	-- set events amount
	local total_events_amount = 0

	for lname, t in pairs(raid_simulation.raid_sim_t) do
		if raid_utils.level_exist(lname) then
			local amount = math.random(events_amount_t[t.level_tier][1], events_amount_t[t.level_tier][2])

			raid_active_events[lname] = {}

			-- store events with matched level tier only
			local ev_t = {}
			for ev_name, v in pairs(events_t) do
				if raid_utils.in_ar(v.tiers, t.level_tier) then
					ev_t[ev_name] = true
				end
			end

			-- choose random events
			for i = 1, amount do
				raid_active_events[lname][i] = {}

				-- pick random
				local random_event = random_key_table(ev_t)

				-- exclude mutually exclusive events
				if events_t[random_event].exclude then
					for j = 1, #events_t[random_event].exclude do
						local ev_to_remove = events_t[random_event].exclude[j]
						if ev_t[ev_to_remove] then
							ev_t[ev_to_remove] = nil
						end
					end
				end

				raid_active_events[lname][i].event = random_event
				raid_active_events[lname][i].tier = t.level_tier
				raid_active_events[lname][i].opened = false
				raid_active_events[lname][i].fake = false

				-- informant bonus
				if events_t[random_event].mod then
					raid_active_events[lname][i].modified = "disabled"
					raid_active_events[lname][i].modified_cost = events_t[random_event].mod
				end

				total_events_amount = total_events_amount + 1

				-- open first event
				if i == 1 then
					raid_active_events[lname][i].opened = true
				end

				-- remove event from ev_t table
				ev_t[random_event] = nil
			end

		end
	end


	-- set fake
	local fake_events = 0
	local mult = clamp(raid_tables.raid_fake_events_mult, 0, 0.99)
	while fake_events < total_events_amount * mult do
		for lname, ar in pairs(raid_active_events) do
			local idx = math.random(1, #ar)
			local event_t = idx and ar[idx]
			if event_t and (not event_t.fake) then
				raid_active_events[lname][idx].fake = true
				fake_events = fake_events + 1
			end
		end
	end


	-- update gui
	if raid_map_gui and raid_map_gui.GUI and raid_map_gui.picked_map ~= "nil" then
		raid_map_gui.GUI:UpdateMapDetails(raid_map_gui.picked_map)
	end

end

function raid_start_event_spawn(level_name)		-- spawned in raid_simulation.script
	local level_events_ar = raid_active_events[level_name]
	if not level_events_ar then return end

	for idx, t in ipairs(level_events_ar) do
		pr("%s Event: %s || modified: %s", t.fake and "$ Fake" or "- Spawn", t.event, t.modified)
		if not (t.fake) then		-- dont spawn fake events
			local event_f = events_t[t.event].func
			_G["raid_events_functors"][event_f](level_name, t.tier, t.modified)
		end
	end

end

function raid_end_events()
	-- remove busy smarts
	empty_table(raid_event_busy_smarts_t)

	-- remove event info portions
	local function itr(id, info)
		if string.find(info, "raid_event") then
			disable_info(info)
		end
	end
	alife():iterate_info(0, itr)

	-- release event squads
	for squad_id, _ in pairs(raid_event_squads) do
		local squad = alife_object(squad_id)
		if squad and squad.commander_id then
			alife_release(squad)
		end
	end

	empty_table(raid_event_squads)
end

function actor_on_first_update()
	-- generate events first time
	if not cur_level then
		generate_events()
		cur_level = level.name()
		return
	end

	-- regenerate events when we return home
	if cur_level ~= level.name() then
		if level.name() == raid_utils.raid_home_level then
			generate_events()
		end
		cur_level = level.name()
	end

end

local tmr = 0
function actor_on_update()
	local tg = time_global()
	if tmr > tg then return end
	tmr = tg + 5000

	-- reset by time only if at home
	if level.name() ~= raid_utils.raid_home_level then return end

	local cur_time = game.get_game_time()
	if reset_time and cur_time:diffSec(t_to_ctime(reset_time)) > raid_tables.event_reset_cooldown then
		generate_events()
	end

end

function pr(...)
	if not raid_tables.raid_events_dbg then return end
	printf(...)
end

function save_state(m_data)
	m_data.raid_active_events = raid_active_events
	m_data.raid_event_squads = raid_event_squads
	m_data.raid_event_busy_smarts_t = raid_event_busy_smarts_t
	m_data.raid_events_reset_time = reset_time
	m_data.raid_events_cur_level = cur_level
end

function load_state(m_data)
	raid_active_events = m_data.raid_active_events or raid_active_events
	raid_event_squads = m_data.raid_event_squads or raid_event_squads
	raid_event_busy_smarts_t = m_data.raid_event_busy_smarts_t or raid_event_busy_smarts_t
	reset_time = m_data.raid_events_reset_time or reset_time
	cur_level = m_data.raid_events_cur_level or cur_level
end

function on_game_start()
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
	RegisterScriptCallback("actor_on_update", actor_on_update)
	RegisterScriptCallback("save_state", save_state)
	RegisterScriptCallback("load_state", load_state)
end