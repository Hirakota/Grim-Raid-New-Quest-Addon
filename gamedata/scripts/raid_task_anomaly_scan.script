local gt = game.translate_string
local ltx = ini_file("misc\\task\\tm_raid_tasks.ltx")
local ctime_to_t = utils_data.CTime_to_table
local t_to_ctime = utils_data.CTime_from_table


-- ============================================
-- =========== (1) Anomaly Scaning ============
-- ============================================
task_functor.raid_task_anomaly_scan_target_functor = function(task_id,field,p,tsk)
	local active_t = raid_tasks_main.raid_active_tasks
	local stage = tsk and tsk.stage

	if (field == "title") then
		return raid_utils.get_raid_task_title(task_id, stage, 5)
	elseif (field == "descr") then
		return raid_utils.get_raid_task_descr(task_id, stage, 5)
	elseif (field == "target") and stage and stage > 0 and active_t[task_id] then

		local item = active_t[task_id].item_id;
		local anomaly = active_t[task_id].smart_id

		if stage == 1 or stage == 4 then 
			return item
		elseif stage == 2 then
			return anomaly
		end
	end
end

task_status_functor.raid_task_anomaly_scan_status_functor = function(tsk,task_id)
	printf("raid_task_anomaly_scan_status_functor stage: %s", tsk.stage);
    local active_t = raid_tasks_main.raid_active_tasks
	local cur_time = game.get_game_time()
	local task_data = raid_tasks_main.get_task_data(task_id)
	if not (task_data and tsk) then return end

	if not tsk.stage then
		tsk.stage = 0
	end

	if tsk.stage > 0 and not active_t[task_id] then
		return
	end
    printf("raid_task_anomaly_scan_status_functor %s", tsk.stage)


--[[
	0 = setup
	1 = pickup scanner
    2 = check if dropped near anomaly
    3 = check if time passed or picked up to early
    4 = delivery out
    5 = dropper take scanner or complete quest
--]]

	-- setup
	if tsk.stage == 0 then
		active_t[task_id] = {}

		-- store level and smart
		active_t[task_id].level_name = task_data.level_name
		active_t[task_id].smart_id = raid_utils.find_random_anomaly(task_data.level_name) or "No anomaly id"

        active_t[task_id].anomaly_scanner_placed = false
        active_t[task_id].anomaly_scanned = false

		-- spawn item and store its id
		local item_sec = "raid_anomaly_scanner"
		local item = alife_create_item(item_sec, db.actor)
		active_t[task_id].item_id = item and item.id or "No item ID"

		-- set timer
		active_t[task_id].start_time = ctime_to_t(cur_time)

		tsk.stage = 1
		return		-- next update just in case
	end

    -- pick up scanner
    if tsk.stage == 1 then
		local item = alife_object(active_t[task_id].item_id)
		if item and item.parent_id and item.parent_id == 0 then
			tsk.stage = 2
		end
        return
    end

	-- dropped check
	if tsk.stage == 2 then
		local item = alife_object(active_t[task_id].item_id)
		if item and item.parent_id and item.parent_id ~= 0 then
			local anomaly = alife_object(active_t[task_id].smart_id)
			if db.actor:position():distance_to(anomaly.position) < 15 then 
				-- droped near anomaly
				active_t[task_id].anomaly_scanner_placed_time = ctime_to_t(cur_time);
        		active_t[task_id].time_to_scan = math.random(60, 200);
				tsk.stage = 3
			else 
				-- if dropped far away pick it up
				tsk.stage = 1
			end
		end
		return
	end

	if tsk.stage == 3 then
		-- check if picked up to early
		local item = alife_object(active_t[task_id].item_id)
		if item and item.parent_id and item.parent_id == 0 then
			tsk.stage = 2
			return
		end
		-- check if tipe passed
		if (cur_time:diffSec(t_to_ctime(active_t[task_id].anomaly_scanner_placed_time)) > (active_t[task_id].time_to_scan)) then
			local str = strformat(gt("anomaly_scan_task_update"), ui_options.curr_player_name())
			news_manager.send_tip(db.actor, str, 3, nil, 5000)
			tsk.stage = 4
		end
		return
	end

    -- pick up scanner
    if tsk.stage == 4 then
		local item = alife_object(active_t[task_id].item_id)
		if item and item.parent_id and item.parent_id == 0 then
			tsk.stage = 5
		else
			return
		end
    end

	-- item dropped
	if tsk.stage == 5 then
		local item = alife_object(active_t[task_id].item_id)
		if item and item.parent_id and item.parent_id ~= 0 then
			tsk.stage = 4
			return
		end
	end

	-- complete
	if tsk.stage == 5 then
		if level.name() == raid_utils.raid_home_level then
			raid_tasks_main.end_raid_task(task_id, "complete")
		end
		return
	end

	-- fail on timer
	if task_data.urgent < 9 then
		local hours = raid_tables.raid_urgency_time[task_data.urgent]
		if cur_time:diffSec(t_to_ctime(active_t[task_id].start_time)) > (hours * 3600) then
			raid_tasks_main.end_raid_task(task_id, "fail")
			return
		end
	end

end