reset_time = false
local ctime_to_t = utils_data.CTime_to_table
local t_to_ctime = utils_data.CTime_from_table
local HI = has_alife_info
local GI = give_info
local DI = disable_info

local raid_task_dbg = false

-- task levels are picked from raid_simulation.raid_sim_t
--[[
1) press button 2 (sec "freedom_raid_1")
2) task becomes "picked"
3) we visit some level and check raid main table
4) if t.level_name matches our current and its not "active"
5) make it "active" and give task (func)
--]]

-- tasks are given in raid_notebook_gui OnAcceptTask function

-- to manually reset tasks use:			raid_tasks_main.generate_tasks()  raid_notebook_gui.GUI:UpdateTaskMenu()

raid_active_tasks = {}

raid_busy_stashes_t = {}
raid_busy_smarts_t = {}

raid_tasks_t = {		-- main table, don't touch "goodwill" and "tasks", everything else can be changed

	["stalker"] = {
		goodwill = 0,
		tasks = {},
		icon = "ui_inGame2_sid",
		name = "escape_trader_name",
		enemies = { "bandit", "army", "killer", "renegade" },
	},

	["duty"] = {
		goodwill = 0,
		tasks = {},
		icon = "ui_inGame2_barman",
		name = "bar_barmen_name",
		enemies = { "bandit", "killer", "freedom", "monolith", "renegade" },
	},

	["freedom"] = {
		goodwill = 0,
		tasks = {},
		icon = "ui_inGame2_skinflint",
		name = "mil_Svoboda_trader_name",
		enemies = { "army", "duty", "monolith", "renegade" },
	},

	["ecolog"] = {
		goodwill = 0,
		tasks = {},
		icon = "ui_inGame2_sakharov",
		name = "yan_st_sakharov_name",
	},

	["other"] = {
		goodwill = 0,
		tasks = {},
		icon = "ui_inGame2_no_data",
		enemies = { "stalker", "duty", "freedom", "bandit", "killer", "army" },
	},

}

local tasks_without_level = {		-- [task_type] = bool
	["find_weapon"] = true,		["find_outfit"] = true,		["find_artefact"] = true,
}

-- generate tasks to display in notebook		(самый ебанутый код на моей памяти который я могу написать в 20 строк и будет тоже самое, но нет... надо именно так)
function generate_tasks()

	printf("START TO TASKS GENERATION");

	local ac_rank = raid_utils.get_actor_rank_name()
	local ac_rank_t = raid_tables.actor_rank_based_tasks[ac_rank]
	local ltx = ini_file("misc\\task\\tm_raid_tasks.ltx")

	-- remove tasks that are not active and store active tasks for later checks
	local active_tasks = {}
	for comm, t in pairs(raid_tasks_t) do
		for sec, task_t in pairs(t.tasks) do
			if task_t.active then
				active_tasks[sec] = true
			else
				raid_tasks_t[comm]["tasks"][sec] = nil
			end
		end
	end


	for comm, t in pairs(raid_tasks_t) do

		-- get trader goodwill based limits and pick random tasks amount
		local key
		local limits_t = raid_tables.task_limits
		for k, v in pairs(limits_t) do
			if t.goodwill >= 0 and t.goodwill >= k and (not key or key < k) then
				key = k
			end
			if t.goodwill < 0 and t.goodwill <= k and (not key or key > k) then
				key = k
			end
		end

		local informant_bonus = HI(raid_notebook_gui.informant_options_ar[1].info) and raid_tables.informant_bonus_tasks_amount or 0		-- informant +tasks bonus
		local tasks_amount = math.random(limits_t[key][1] + informant_bonus, limits_t[key][2] + informant_bonus);


		-- get all task sections from ltx for this comm except already picked tasks
		local task_sections = {}
		ltx:section_for_each(function(section)
			if string.find(section, comm .. "_raid_task") and (not active_tasks[section]) then

				pr("----------------------------")
				pr("found in ltx non-active task [%s]", section)

				-- get task type and then possible max tier
				local task_type = string.gsub(section, comm .. "_raid_task_", "")
				pr("task_type: %s", task_type)
				local min_tier = raid_tables.task_minmax_tiers[task_type][1]
				local max_tier = raid_tables.task_minmax_tiers[task_type][2]
				pr("task min tier: %s || max tier: %s", min_tier, max_tier)

				-- store with default parameters
				task_sections[section] = {}
				task_sections[section].typ = task_type
				task_sections[section].urgent = 4
				task_sections[section].tier = 1

				-- try to set random urgency for this task
				pr("index in urgency table: %s", raid_tables.task_urgency[task_type])
				if raid_tables.task_urgency[task_type] < 4 then
					task_sections[section].urgent = math.random(1, raid_tables.task_urgency[task_type])
				end

				-- try to set higher tier for this task
				local rnd = math.random(100)
				if rnd <= ac_rank_t[3] and (max_tier >= 3) then
					task_sections[section].tier = 3
				elseif rnd <= (ac_rank_t[3] + ac_rank_t[2]) and (max_tier >= 2) then
					task_sections[section].tier = 2
				end

				-- clamp max tier
				if task_sections[section].tier > max_tier then
					task_sections[section].tier = max_tier
				end

				-- delete task from list if it did not reach minimum tier
				if task_sections[section].tier < min_tier then
					pr("! task min_tier is higher, remove from list")
					task_sections[section] = nil
				end

			end
		end)


		-- pick random tasks until "tasks_amount" is reached
		for i = 1, tasks_amount do
			if (not is_empty(task_sections)) then

				local sec = random_key_table(task_sections)

				-- store this task info
				raid_tasks_t[comm]["tasks"][sec] = {}
				raid_tasks_t[comm]["tasks"][sec].active = false

				raid_tasks_t[comm]["tasks"][sec].typ = task_sections[sec].typ
				raid_tasks_t[comm]["tasks"][sec].tier = task_sections[sec].tier
				raid_tasks_t[comm]["tasks"][sec].urgent = task_sections[sec].urgent
				raid_tasks_t[comm]["tasks"][sec].comm = comm

				-- set rewards
				if raid_tables.task_reward_mults[task_sections[sec].typ] then
					raid_tasks_t[comm]["tasks"][sec].reward = raid_utils.get_task_reward(comm, task_sections[sec])
				elseif raid_tables.task_special_reward[task_sections[sec].typ] then
					raid_tasks_t[comm]["tasks"][sec].special_reward_mult = raid_utils.get_task_reward(comm, task_sections[sec], true)
				end

				-- get all levels of this tier and pick random
				local all_levels_t = {}
				for lname, lt in pairs(raid_simulation.raid_sim_t) do
					if raid_utils.level_exist(lname) then
						local tier_cond = (lt.level_tier == 4 and task_sections[sec].tier == 3) or (lt.level_tier == task_sections[sec].tier)
						if tier_cond then
							all_levels_t[lname] = true
						end
					end
				end
				local level_name = tasks_without_level[task_sections[sec].typ] and "nil" or random_key_table(all_levels_t)
				raid_tasks_t[comm]["tasks"][sec].level_name = level_name

				-- store reciver freq
				if task_sections[sec].typ == "rf_scout_and_delivery_out" or task_sections[sec].typ == "rf_find_and_delivery_out" then
					local freq = math.random(30, 300)
					raid_tasks_t[comm]["tasks"][sec].target_freq = freq
				end

				-- store kill stalker info
				if task_sections[sec].typ == "kill_stalker" or task_sections[sec].typ == "kill_stalker_squad" or task_sections[sec].typ == "kill_stalker_and_delivery_out" then
					local enemy_sec = raid_utils.get_kill_target_squad_sec(t.enemies, task_sections[sec].tier)
					raid_tasks_t[comm]["tasks"][sec].kill_stalker_squad_sec = enemy_sec
				end

				-- store strong kill stalker info
				if task_sections[sec].typ == "kill_strong_stalker_squad" then
					local enemy_sec = "raid_strong_stalker_squad_" .. math.random(1, 2)
					raid_tasks_t[comm]["tasks"][sec].kill_strong_stalker_squad_sec = enemy_sec
				end

				-- store kill mutant squad info
				if task_sections[sec].typ == "kill_mutant_squad" then
					local enemy_ar = raid_tables.mutant_enemies[task_sections[sec].tier]
					local rnd_mutant = enemy_ar[math.random(1, #enemy_ar)]
					local enemy_sec = ""
					repeat
						local rnd_sec = "raid_simulation_" .. rnd_mutant .. "_" .. math.random(1, 4)
						if ini_sys:section_exist(rnd_sec) then
							enemy_sec = rnd_sec
						end
					until enemy_sec ~= ""
					raid_tasks_t[comm]["tasks"][sec].kill_mutant_squad_sec = enemy_sec
				end

				-- store strong kill mutants squad info
				if task_sections[sec].typ == "kill_strong_mutant_squad" then
					local enemy_sec = "raid_strong_mutant_squad_" .. math.random(1, 2)
					raid_tasks_t[comm]["tasks"][sec].kill_strong_mutant_squad_sec = enemy_sec
				end

				-- store find weapon sec
				if task_sections[sec].typ == "find_weapon" then
					local wpn_group = raid_utils.get_weapon_list()
					raid_tasks_t[comm]["tasks"][sec].group = wpn_group
				end

				-- store find armor comm
				if task_sections[sec].typ == "find_outfit" then
					local outf_comm = raid_utils.get_armor_list(true)
					raid_tasks_t[comm]["tasks"][sec].group = outf_comm
				end

				-- store artefact group
				if task_sections[sec].typ == "find_artefact" then
					local art_group = raid_utils.get_artefact_list(true)
					raid_tasks_t[comm]["tasks"][sec].group = art_group
				end

				-- and remove task from "task_sections" table
				task_sections[sec] = nil

			end
		end

	end


	-- sort tasks by level name
	local all_sec_ar = {}
	for i = 1, 4 do
		all_sec_ar[i] = {}
	end
	for comm, t in pairs(raid_tasks_t) do
		for sec, task_t in pairs(t.tasks) do
			if (not task_t.active) then
				if task_t.level_name ~= "nil" then
					all_sec_ar[task_t.tier][task_t.level_name] = all_sec_ar[task_t.tier][task_t.level_name] or {}
					table.insert(all_sec_ar[task_t.tier][task_t.level_name], sec)
				else
					all_sec_ar[4]["no_level"] = all_sec_ar[4]["no_level"] or {}
					table.insert(all_sec_ar[4]["no_level"], sec)
				end
			end
		end
	end

	-- sort into general array by order
	local sorted_ar = {}
	for idx, t in ipairs(all_sec_ar) do
		for lname, sec_ar in pairs(t) do
			for _, sec in ipairs(sec_ar) do
				sorted_ar[#sorted_ar + 1] = sec
			end
		end
	end

	for comm, t in pairs(raid_tasks_t) do
		for sec, task_t in pairs(t.tasks) do
			for i = 1, #sorted_ar do
				if sorted_ar[i] == sec then
					raid_tasks_t[comm]["tasks"][sec].gui_index = i
				end
			end
		end
	end

end

function end_raid_task(task_id, mode, reward)

	if mode == "complete" then
		task_manager.get_task_manager():set_task_completed(task_id)
		-- give reward and msg
		for comm, t in pairs(raid_tasks_t) do
			if t.tasks[task_id] then
				raid_utils.raid_send_task_msg(t.tasks[task_id], "complete")
				raid_utils.give_task_reward(t.tasks[task_id], comm, task_id)

				-- For achievements
				if (not string.find(task_id, "find_")) then
					raid_achievements.increment_count_complete_tasks_raid()
				end
			end
		end
	elseif mode == "fail" then
		task_manager.get_task_manager():set_task_failed(task_id)
		-- penalties and msg
		for comm, t in pairs(raid_tasks_t) do
			if t.tasks[task_id] then
				raid_utils.raid_send_task_msg(t.tasks[task_id], "fail")
				raid_utils.give_task_penalty(comm, task_id)
			end
		end
	elseif mode == "cancel" then
		task_manager.get_task_manager():set_task_cancelled(task_id)
	end

	-- remove from the main table
	for comm, t in pairs(raid_tasks_t) do
		if t.tasks[task_id] then
			raid_tasks_t[comm]["tasks"][task_id] = nil
		end
	end

	-- remove from busy stash/smart tables
	local stash_id = raid_active_tasks[task_id].stash_id
	if stash_id and raid_busy_stashes_t[stash_id] then
		raid_busy_stashes_t[stash_id] = nil
	end

	local smart_id = raid_active_tasks[task_id].smart_id
	if smart_id and raid_busy_smarts_t[smart_id] then
		raid_busy_smarts_t[smart_id] = nil
	end

	-- release item in "delivery"
	local in_cond = string.find(task_id, "delivery_in") and raid_active_tasks[task_id].item_id
	-- every task that include delivery_out
	local out_cond = string.find(task_id, "delivery_out")
	local scan_cond = string.find(task_id, "anomaly_scan")
	-- local k_out_cond = string.find(task_id, "kill_stalker_and_delivery_out")
	-- local rf_out_cond = string.find(task_id, "rf_scout_and_delivery_out")
	local out_world_cond = string.find(task_id, "delivery_out_world")
	local mines_cond = string.find(task_id, "delivery_mines") and raid_active_tasks[task_id].item_id

	if scan_cond or out_cond or out_world_cond or mines_cond then
		local item = alife_object(raid_active_tasks[task_id].item_id)
		alife_release(item)
	end

	-- unmark in "scout"
	if string.find(task_id, "scout") then
		for sm_id, str in pairs(raid_active_tasks[task_id].smarts_t) do
			raid_tasks_scout.unmark_smart(sm_id)
		end
	end
	-- unmark in "find_squad_and_delivery_out"
	if string.find(task_id, "find_squad_and_delivery_out") then
		for idx, smart_id in pairs(active_t[task_id].nearest_smart_ids) do
			raid_sudden_task_find_squad_and_delivery_out.unmark_smart(smart_id)
		end
	end

	-- release unkilled squads
	local release_t = {
		["kill_stalker_squad"] = "stalker_squad_id",		["kill_stalker"] = "squad_id",		["kill_mutant_squad"] = "mutant_squad_id",
		["evacuation"] = "evac_squad_id",		["guide"] = "guide_squad_id", 		["kill_strong_stalker_squad"] = "strong_stalker_squad_id",
		["kill_strong_mutant_squad"] = "strong_mutant_squad_id", ["kill_stalker_and_delivery_out"] = "squad_id",
	}

	for str, key in pairs(release_t) do
		if string.find(task_id, str) then
			local sq_id = raid_active_tasks[task_id][key]
			local squad = sq_id and sq_id < 65535 and alife_object(sq_id)		-- checks to bypass annoying warning spam
			if squad and squad.commander_id then
				alife_release(squad)
			end
		end
	end

	-- release "find" item in quest box
	local found_item_id = string.find(task_id, "find_") and raid_active_tasks[task_id].found_item_id
	local found_item = found_item_id and alife_object(found_item_id)
	if found_item then
		alife_release(found_item)
	end

	-- remove from active tasks
	raid_active_tasks[task_id] = nil

end

function get_task_data(task_id)
	local ret_t = {}
	for comm, t in pairs(raid_tasks_t) do
		if t.tasks[task_id] then
			ret_t = dup_table(t.tasks[task_id])
			return ret_t
		end
	end
end

function set_all_tasks_to(mode, lvl_name)
	for task_id, t in pairs(raid_active_tasks) do
		local always_fail = string.find(task_id, "delivery_in") or string.find(task_id, "delivery_mines")			-- это блять вообще пиздец, потом ходи ищи
		if always_fail or t.level_name == lvl_name then
			end_raid_task(task_id, mode)
		end
	end
end

--[[
local tmr = 0
local cur_day = ""
function reset_tasks_update()
	local tg = time_global()
	if tmr > tg then return end
	tmr = tg + 1500

	local date = game.get_game_time():dateToString(game.CTime.DateToDay)
	local day = date:match(".-(%d+).-([%d%.%,]+)")
	if cur_day ~= day and level.get_time_hours() >= 4 then
		-- do something
		cur_day = day
	end
end
--]]

local tmr = 0
function reset_tasks_update()
	local tg = time_global()
	if tmr > tg then return end
	tmr = tg + 1500

	local cur_time = game.get_game_time()
	if (not reset_time) or cur_time:diffSec(t_to_ctime(reset_time)) > raid_tables.task_reset_cooldown then
		--	local Y, M, D, h, m, s, ms = 0, 0, 0, 0, 0, 0, 0
		--	Y, M, D, h, m, s, ms = cur_time:get(Y, M, D, h, m, s, ms)
		--	cur_time:set(Y, M, D, 4, 0, 0, 0)
		reset_time = ctime_to_t(cur_time)

		-- reset tasks
		generate_tasks()

		-- enable informant extra tasks button
		if HI(raid_notebook_gui.informant_options_ar[1].info) then
			DI(raid_notebook_gui.informant_options_ar[1].info)
		end

		-- update tasks in GUI
		if raid_notebook_gui and raid_notebook_gui.GUI then
			raid_notebook_gui.GUI:UpdateTaskMenu()
		end
	end
end

function pr(...)
	if not raid_task_dbg then return end
	printf(...)
end

-- give sunndent task on npc death
function squad_on_npc_death(squad, se_obj, se_killer)
	local isSquadTracked = raid_simulation.raid_squad_track_id and (squad.id == raid_simulation.raid_squad_track_id)

	if not isSquadTracked then
		return
	end

	local squadSize = raid_utils.get_squad_size(squad.id)

	if squadSize > 0 then
		return
	end

	-- chance in 40% to not recive a quest
	if math.random(1, 100) > 100 then
		printf("# Roll failed to recive a quest")
		raid_simulation.raid_squad_track_id = nil
		return
	end

	local ltx = ini_file("misc\\task\\tm_raid_sudden_tasks.ltx")

	local comm = nil
	for c, t in pairs(raid_tasks_t) do
		if string.find(squad:name(), c) then
			if c == "csky" then
				comm = "stalker"
			else
				comm = c
			end
			break
		end
	end

	if not comm then
		comm = random_key_table(raid_tasks_t)
	end


	local target_section = nil
	local task_base_data = {}
	local sections = {}

	ltx:section_for_each(function(section)
		if string.find(section, comm .. "_raid_sudden_task_find_squad_and_delivery_out") then
			local task_type = string.gsub(section, comm .. "_raid_sudden_task_", "")
			pr("task_type: %s", task_type)

			-- store with default parameters
			task_base_data.typ = task_type
			task_base_data.urgent = 1
			task_base_data.tier = 1

			target_section = section
			table.insert( sections, section )
		end
	end)

	if not target_section then
		raid_simulation.raid_squad_track_id = nil
		return;
	end

	-- store this task info
	raid_tasks_t[comm]["tasks"][target_section] = {}
	raid_tasks_t[comm]["tasks"][target_section].active = false

	raid_tasks_t[comm]["tasks"][target_section].typ = task_base_data.typ
	raid_tasks_t[comm]["tasks"][target_section].tier = task_base_data.tier
	raid_tasks_t[comm]["tasks"][target_section].urgent = task_base_data.urgent
	raid_tasks_t[comm]["tasks"][target_section].comm = comm

	local freq = math.random(30, 300)
	raid_tasks_t[comm]["tasks"][target_section].target_freq = freq

	-- set rewards
	if raid_tables.task_reward_mults[task_base_data.typ] then
		raid_tasks_t[comm]["tasks"][target_section].reward = raid_utils.get_task_reward(comm, task_base_data)
	elseif raid_tables.task_special_reward[task_base_data.typ] then
		raid_tasks_t[comm]["tasks"][target_section].special_reward_mult = raid_utils.get_task_reward(comm, task_base_data, true)
	end

	-- find current level tier
	for lname, lt in pairs(raid_simulation.raid_sim_t) do
		if lname == level.name() then
			raid_tasks_t[comm]["tasks"][target_section].tier = lt.level_tier
			break
		end
	end

	raid_tasks_t[comm]["tasks"][target_section].level_name = level.name()

	-- setup body data
	local body = alife_object(squad:commander_id())
	raid_tasks_t[comm]["tasks"][target_section].stalker_id = body.id
    body:can_switch_offline(false)  -- Keep object always active
    body:keep_saved_data_anyway(true)  -- Force save persistence

	task_manager.get_task_manager():give_task(target_section)
end

function save_state(m_data)
	m_data.raid_active_tasks = raid_active_tasks
	m_data.raid_tasks_t = raid_tasks_t
	m_data.raid_busy_stashes_t = raid_busy_stashes_t
	m_data.raid_busy_smarts_t = raid_busy_smarts_t

	m_data.raid_reset_time = reset_time
end

function load_state(m_data)
	raid_active_tasks = m_data.raid_active_tasks or raid_active_tasks

	--	raid_tasks_t = m_data.raid_tasks_t or raid_tasks_t
	if m_data.raid_tasks_t then
		for comm, t in pairs(m_data.raid_tasks_t) do
			raid_tasks_t[comm].goodwill = t.goodwill
			raid_tasks_t[comm].tasks = t.tasks
		end
	end

	raid_busy_stashes_t = m_data.raid_busy_stashes_t or raid_busy_stashes_t
	raid_busy_smarts_t = m_data.raid_busy_smarts_t or raid_busy_smarts_t

	reset_time = m_data.raid_reset_time or reset_time
end


-- Simple direct hook (may need to be in correct load order)
Crelease_body = release_body_manager.Crelease_body
if Crelease_body and Crelease_body.can_release then
    local original = Crelease_body.can_release
    Crelease_body.can_release = function(self, obj)
		local objId = obj:id()
		local raid_squad_track_id = raid_simulation.raid_squad_track_id
		if raid_squad_track_id and objId and objId == raid_squad_track_id then
			local str = "---------------------------\n"
			local info = "GC HOOK: prevent body with id " .. objId .. " from remove tackId: " .. raid_squad_track_id .. "\n"
			printf(str)
			printf(info)
			printf(str)
			return false
		end

        return original(self, obj)
    end
end

function on_game_start()
	RegisterScriptCallback("actor_on_update", reset_tasks_update)
	RegisterScriptCallback("squad_on_npc_death", squad_on_npc_death)
	RegisterScriptCallback("save_state", save_state)
	RegisterScriptCallback("load_state", load_state)
end
