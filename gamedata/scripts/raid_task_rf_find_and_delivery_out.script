local gt = game.translate_string
local ltx = ini_file("misc\\task\\tm_raid_tasks.ltx")
local ctime_to_t = utils_data.CTime_to_table
local t_to_ctime = utils_data.CTime_from_table

local tb_tg_scan = 0
local tb_scan_time = 4000;

local delivery_sec_t = { -- item indices
    ["in"] = { 1, 2, 3, 4, 5 },
    ["out"] = { 6, 7, 8, 9, 10, 11 },
}


-- ============================================
-- ======== (1) RF search and delivery =========
-- ============================================
task_functor.raid_task_rf_find_and_delivery_out_target_functor = function(task_id, field, p, tsk)
    local active_t = raid_tasks_main.raid_active_tasks
    local stage = tsk and tsk.stage

    if (field == "title") then
        return raid_utils.get_raid_task_title(task_id, stage, 4)
    elseif (field == "descr") then
        return raid_utils.get_raid_task_descr(task_id, stage, 4)
    elseif (field == "target") and stage and stage > 0 and active_t[task_id] then
        -- uncomment for debug (mark target stash)
        -- if(tsk.stage == 1) then
        -- return active_t[task_id].stash_id
        -- end
        if tsk.stage == 2 or tsk.stage == 3 then
            return active_t[task_id].item_id
        end
        return
    end
end

task_status_functor.raid_task_rf_find_and_delivery_out_status_functor = function(tsk, task_id)
    local active_t = raid_tasks_main.raid_active_tasks
    local cur_time = game.get_game_time()
    local task_data = raid_tasks_main.get_task_data(task_id)
    if not (task_data and tsk) then return end

    if not tsk.stage then
        tsk.stage = 0
    end

    if tsk.stage > 0 and not active_t[task_id] then
        return
    end

    --[[
	0 = setup
	1 = process
	2 = completed setup delivery (0)
	3 = taking process (1)
	4 = quest item dropped (2)
	5 = taken (3)
    --]]

    -- setup
    if tsk.stage == 0 then
        active_t[task_id] = {}

        -- store level and stash
        active_t[task_id].level_name = task_data.level_name
        active_t[task_id].stash_id = raid_utils.find_random_stash(task_data.level_name, true) or "No stash id"
        raid_tasks_main.raid_busy_stashes_t[active_t[task_id].stash_id] = true

        -- spawn item in stash and store its id
        local itm_ar = delivery_sec_t["out"]
        local item_sec = "raid_delivery_item_" .. itm_ar[math.random(1, #itm_ar)]
        local se_stash = alife_object(active_t[task_id].stash_id)
        local item = alife_create_item(item_sec, se_stash)
        active_t[task_id].item_sec = item_sec
        active_t[task_id].item_id = item and item.id or "No item ID"
        active_t[task_id].ping_sound = true

        -- set timer
        active_t[task_id].start_time = ctime_to_t(cur_time)

        tsk.stage = 1
        return -- next update just in case
    end

    if tsk.stage == 1 then
        local item = alife_object(active_t[task_id].item_id)
        if item and item.parent_id and item.parent_id == 0 then
            tsk.stage = 2
            active_t[task_id].ping_sound = false
        end
        return
    end

    -- item taken delivery
    if tsk.stage == 2 or tsk.stage == 3 then
        local item = alife_object(active_t[task_id].item_id)
        if item and item.parent_id and item.parent_id == 0 then
            tsk.stage = 4
        end
    end

    -- item dropped delivery
    if tsk.stage == 4 then
        local item = alife_object(active_t[task_id].item_id)
        if item and item.parent_id and item.parent_id ~= 0 then
            tsk.stage = 3
        end
    end


    -- complete delivery
    if tsk.stage == 4 then
        if level.name() == raid_utils.raid_home_level then
            raid_tasks_main.end_raid_task(task_id, "complete")
        end
        return
    end

    -- fail on timer
    if task_data.urgent < 5 then
        local hours = raid_tables.raid_urgency_time[task_data.urgent]
        if cur_time:diffSec(t_to_ctime(active_t[task_id].start_time)) > (hours * 3600) then
            raid_tasks_main.end_raid_task(task_id, "fail")
            return
        end
    end
end

function boop_if_nearby(stash_id)
    local tg = time_global()

    if (tg > tb_tg_scan) then
        tb_tg_scan = tg + tb_scan_time
    else
        return
    end

    local se_obj = alife_object(stash_id)
    if se_obj then
        local objpos = se_obj.position
        local dist_pos = db.actor:position():distance_to(objpos)

        local lowbeep = ("detectors\\tb_lowbeep")

        if dist_pos < 300 then
            tb_scan_time = 50 + dist_pos * 10
            xr_effects.play_snd(actor, nil, {
                [1] = lowbeep
            })
            return
        end
    end
end

function actor_on_update()
    local active_t = raid_tasks_main.raid_active_tasks


    for task_id, t in pairs(active_t) do
        local task_data = raid_tasks_main.get_task_data(task_id)
        local cur_task = active_t[task_id]

        if string.find(task_data.typ, "rf_find") and task_data.level_name == level.name() and cur_task.ping_sound and raid_utils.isRfScanning(task_data.target_freq)  then
            boop_if_nearby(cur_task.stash_id)
        end
    end
end

function on_game_start()
    RegisterScriptCallback("actor_on_update", actor_on_update)
end
